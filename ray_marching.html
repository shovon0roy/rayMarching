<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ray Tracing vs. Ray Marching Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #f3f4f6;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas {
            display: block;
        }
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 350px;
        }
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }
        .btn-primary {
            background-color: #4f46e5;
            color: white;
        }
        .btn-primary:hover {
            background-color: #4338ca;
        }
        .btn-secondary {
            background-color: #e5e7eb;
            color: #374151;
        }
        .btn-secondary.active {
            background-color: #3b82f6;
            color: white;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="ui-panel">
        <h1 class="text-2xl font-bold mb-2">3D Simulation</h1>
        <p class="text-gray-600 mb-4">Visually compare Ray Tracing and Ray Marching. Use your mouse to rotate the scene.</p>
        
        <div class="flex space-x-2 mb-4">
            <button id="trace-mode-btn" class="btn btn-secondary flex-1">Ray Tracing</button>
            <button id="march-mode-btn" class="btn btn-secondary flex-1">Ray Marching</button>
        </div>
        
        <button id="fire-ray-btn" class="btn btn-primary w-full mb-4">Fire Ray</button>
        
        <div id="info-box" class="bg-gray-50 p-3 rounded-lg">
            <h2 id="info-title" class="font-bold text-lg mb-1">Select a Mode</h2>
            <p id="info-text" class="text-gray-700">Choose a rendering technique and click "Fire Ray" to see it in action.</p>
        </div>

        <!-- Calculation Log Panel -->
        <div id="calc-log-container" class="mt-4 hidden">
            <h3 class="font-bold text-lg mb-2">Live Calculation</h3>
            <div id="calc-log" class="bg-gray-800 text-white font-mono text-xs p-3 rounded-lg h-40 overflow-y-auto whitespace-pre">
                <!-- Steps will be added here by JS -->
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Basic Setup ---
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf3f4f6);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // --- Scene Objects ---
        const objects = [];
        const defaultMaterials = {};

        const sphereGeo = new THREE.SphereGeometry(3, 32, 32);
        const sphereMat = new THREE.MeshStandardMaterial({ color: 0x3b82f6 });
        const sphere = new THREE.Mesh(sphereGeo, sphereMat);
        sphere.position.set(-5, 3, 0);
        sphere.name = "Blue Sphere";
        scene.add(sphere);
        objects.push(sphere);
        defaultMaterials[sphere.uuid] = sphereMat;

        const boxGeo = new THREE.BoxGeometry(4, 4, 4);
        const boxMat = new THREE.MeshStandardMaterial({ color: 0x10b981 });
        const box = new THREE.Mesh(boxGeo, boxMat);
        box.position.set(5, 2, -2);
        box.name = "Green Cube";
        scene.add(box);
        objects.push(box);
        defaultMaterials[box.uuid] = boxMat;
        
        const smallSphereGeo = new THREE.SphereGeometry(1.5, 32, 32);
        const smallSphereMat = new THREE.MeshStandardMaterial({ color: 0xef4444 });
        const smallSphere = new THREE.Mesh(smallSphereGeo, smallSphereMat);
        smallSphere.position.set(0, 1.5, 5);
        smallSphere.name = "Red Sphere";
        scene.add(smallSphere);
        objects.push(smallSphere);
        defaultMaterials[smallSphere.uuid] = smallSphereMat;

        const groundGeo = new THREE.PlaneGeometry(50, 50);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0xd1d5db, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // --- UI & State ---
        let mode = null; // 'trace' or 'march'
        const traceModeBtn = document.getElementById('trace-mode-btn');
        const marchModeBtn = document.getElementById('march-mode-btn');
        const fireRayBtn = document.getElementById('fire-ray-btn');
        const infoTitle = document.getElementById('info-title');
        const infoText = document.getElementById('info-text');
        const calcLogContainer = document.getElementById('calc-log-container');
        const calcLog = document.getElementById('calc-log');
        
        const highlightMaterial = new THREE.MeshStandardMaterial({ color: 0xfacc15, emissive: 0xccad00 });
        let currentRayObjects = [];
        let currentMarchData = null; // Holds data for manual stepping

        function setMode(newMode) {
            mode = newMode;
            traceModeBtn.classList.toggle('active', mode === 'trace');
            marchModeBtn.classList.toggle('active', mode === 'march');
            calcLogContainer.classList.toggle('hidden', mode !== 'march');
            updateInfoBox();
        }

        function updateInfoBox() {
            if (mode === 'trace') {
                infoTitle.textContent = "Ray Tracing Mode";
                infoText.textContent = "A single ray is cast. The exact intersection with the closest object is calculated instantly. This is precise and efficient for simple geometry.";
            } else if (mode === 'march') {
                infoTitle.textContent = "Ray Marching Mode";
                infoText.innerHTML = "Press the <b>Spacebar</b> to advance the ray one step at a time.";
            } else {
                infoTitle.textContent = "Select a Mode";
                infoText.textContent = "Choose a rendering technique and click 'Fire Ray' to see it in action.";
            }
        }

        traceModeBtn.addEventListener('click', () => setMode('trace'));
        marchModeBtn.addEventListener('click', () => setMode('march'));
        fireRayBtn.addEventListener('click', () => {
            if (mode) fireRay();
            else alert("Please select a mode first!");
        });

        // --- Ray Logic ---
        const raycaster = new THREE.Raycaster();

        function clearPreviousRay() {
            currentMarchData = null; // Stop any ongoing march
            currentRayObjects.forEach(obj => scene.remove(obj));
            currentRayObjects = [];
            objects.forEach(obj => {
                obj.material = defaultMaterials[obj.uuid];
            });
            calcLog.innerHTML = '';
        }

        function fireRay() {
            clearPreviousRay();
            
            const rayOrigin = camera.position.clone();
            const rayDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);

            if (mode === 'trace') {
                performRayTrace(rayOrigin, rayDirection);
            } else if (mode === 'march') {
                performRayMarch(rayOrigin, rayDirection);
            }
        }

        function performRayTrace(origin, direction) {
            raycaster.set(origin, direction);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                const closestHit = intersects[0];
                const hitPoint = closestHit.point;
                
                const lineGeo = new THREE.BufferGeometry().setFromPoints([origin, hitPoint]);
                const lineMat = new THREE.LineBasicMaterial({ color: 0xef4444, linewidth: 2 });
                const line = new THREE.Line(lineGeo, lineMat);
                scene.add(line);
                currentRayObjects.push(line);

                closestHit.object.material = highlightMaterial;
                infoText.textContent = `Hit ${closestHit.object.name} at distance ${closestHit.distance.toFixed(2)}. (1 calculation)`;
            } else {
                infoText.textContent = "Ray missed all objects.";
            }
        }
        
        // --- SDFs (Signed Distance Functions) for Ray Marching ---
        function sdfSphere(p, center, radius) {
            return p.distanceTo(center) - radius;
        }

        function sdfBox(p, center, size) {
            const offset = p.clone().sub(center);
            
            offset.x = Math.abs(offset.x);
            offset.y = Math.abs(offset.y);
            offset.z = Math.abs(offset.z);

            const q = offset.sub(size);
            
            const outsideDistance = (new THREE.Vector3()).copy(q).max(new THREE.Vector3(0,0,0)).length();
            const insideDistance = Math.min(Math.max(q.x, q.y, q.z), 0.0);

            return outsideDistance + insideDistance;
        }

        function sceneSDF(p) {
            const distSphere = sdfSphere(p, sphere.position, 3);
            const distBox = sdfBox(p, box.position, new THREE.Vector3(2, 2, 2));
            const distSmallSphere = sdfSphere(p, smallSphere.position, 1.5);
            return Math.min(distSphere, distBox, distSmallSphere);
        }

        function getHitObject(p) {
            const distSphere = sdfSphere(p, sphere.position, 3);
            const distBox = sdfBox(p, box.position, new THREE.Vector3(2, 2, 2));
            const distSmallSphere = sdfSphere(p, smallSphere.position, 1.5);
            const min_dist = Math.min(distSphere, distBox, distSmallSphere);

            if(min_dist === distSphere) return sphere;
            if(min_dist === distBox) return box;
            if(min_dist === distSmallSphere) return smallSphere;
            return null;
        }
        
        function getHeatmapColor(t) {
            const colors = [ new THREE.Color(0x00ff00), new THREE.Color(0xffff00), new THREE.Color(0xff0000) ];
            const colorStops = [0, 0.5, 1];
            t = Math.max(0, Math.min(1, t));
            for (let i = 0; i < colorStops.length - 1; i++) {
                const startStop = colorStops[i];
                const endStop = colorStops[i+1];
                if (t >= startStop && t <= endStop) {
                    const localT = (t - startStop) / (endStop - startStop);
                    return new THREE.Color().lerpColors(colors[i], colors[i+1], localT);
                }
            }
            return colors[colors.length - 1];
        }

        function performRayMarch(origin, direction) {
            updateInfoBox(); // Show the "Press Spacebar" message
            currentMarchData = {
                currentPos: origin.clone(),
                direction: direction,
                steps: 0,
                origin: origin.clone()
            };
            // Perform the first step automatically to show the initial state
            marchStep(currentMarchData);
        }

        function marchStep(data) {
            const MAX_STEPS = 100;
            const HIT_THRESHOLD = 0.01;
            const MAX_DIST = 100;

            data.steps++;
            if (data.steps > MAX_STEPS) {
                infoText.innerHTML = `Ray missed after ${data.steps - 1} steps (max steps reached).`;
                currentMarchData = null; // End march
                return;
            }

            // Individual SDF calculations for logging
            const distSphere = sdfSphere(data.currentPos, sphere.position, 3);
            const distBox = sdfBox(data.currentPos, box.position, new THREE.Vector3(2, 2, 2));
            const distSmallSphere = sdfSphere(data.currentPos, smallSphere.position, 1.5);
            const dist = Math.min(distSphere, distBox, distSmallSphere);

            // Update calculation log
            calcLog.innerHTML = `<b>Step ${data.steps}</b>\n` +
                                `distToBlueSphere = ${distSphere.toFixed(3)}\n` +
                                `distToGreenCube  = ${distBox.toFixed(3)}\n` +
                                `distToRedSphere  = ${distSmallSphere.toFixed(3)}\n\n` +
                                `<b>min() -> Step Size = ${dist.toFixed(3)}</b>`;
            calcLog.scrollTop = calcLog.scrollHeight;

            if (isNaN(dist)) {
                infoText.innerHTML = "A calculation error occurred. Please try again from a different angle.";
                currentMarchData = null; // End march
                return;
            }
            
            const t = data.steps / (MAX_STEPS * 0.7);
            const stepColor = getHeatmapColor(t);
            const stepSphereGeo = new THREE.SphereGeometry(Math.max(0.001, dist), 16, 16);
            const stepSphereMat = new THREE.MeshBasicMaterial({ color: stepColor, wireframe: true, transparent: true, opacity: 0.7 });
            const stepSphere = new THREE.Mesh(stepSphereGeo, stepSphereMat);
            stepSphere.position.copy(data.currentPos);
            scene.add(stepSphere);
            currentRayObjects.push(stepSphere);

            // Store start point for the line segment
            const startPoint = data.currentPos.clone();

            // Advance the position for the next step
            data.currentPos.add(data.direction.clone().multiplyScalar(dist));
            
            // Draw the line segment for the step just taken
            const lineGeo = new THREE.BufferGeometry().setFromPoints([startPoint, data.currentPos]);
            const lineMat = new THREE.LineBasicMaterial({ color: 0x374151, linewidth: 2 }); // A dark gray for the ray path
            const line = new THREE.Line(lineGeo, lineMat);
            scene.add(line);
            currentRayObjects.push(line);


            if (dist < HIT_THRESHOLD) {
                const hitObject = getHitObject(data.currentPos);
                if (hitObject) {
                    hitObject.material = highlightMaterial;
                    infoText.innerHTML = `Hit <b>${hitObject.name}</b> after ${data.steps} steps.`;
                } else {
                    infoText.innerHTML = `Hit something after ${data.steps} steps.`;
                }
                currentMarchData = null; // End march
                return;
            }
            
            if (data.currentPos.distanceTo(data.origin) > MAX_DIST) {
                infoText.innerHTML = `Ray missed after ${data.steps} steps.`;
                currentMarchData = null; // End march
                return;
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Event Listeners ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        window.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && currentMarchData) {
                event.preventDefault(); // Prevent space from scrolling the page
                marchStep(currentMarchData);
            }
        });

        animate();
        setMode('trace'); // Start in trace mode by default

    </script>
</body>
</html>
